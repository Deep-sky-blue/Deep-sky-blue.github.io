<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>理解什么是CMDB</title>
    <url>/2021/12/15/CMDB/</url>
    <content><![CDATA[<h2 id="什么是-CMDB"><a href="#什么是-CMDB" class="headerlink" title="什么是 CMDB"></a>什么是 CMDB</h2><p>CMDB 是 Configuration Management Database 的简称，中文翻译成配置管理数据库,是一个逻辑数据库，包含了配置项全生命周期及配置项之间的关系（物理关系，时事通讯关系，非实时通讯关系，依赖关系）</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>主要是存储企业 IT 架构的中设备的各种配置信息，支持服务流程的运转，发挥配置信息的价值。有了配置信息的基础，后续的各种标准，流程都可以建立在 CMDB 的基础上，实现标准化，自动化，智能运维，节约时间成本和传统运维失误的风险。</p>
<h2 id="最终目的"><a href="#最终目的" class="headerlink" title="最终目的"></a>最终目的</h2><ol>
<li>项目上线<br> 需要实现一个自动化部署项目的工具，不是简单的 shell 脚本，包括服务器的 ip，cpu,硬盘等都需要考虑，这些就需要 CMDB 作为基础</li>
<li>监控系统<br> 检测服务器运行期间的各种状态，硬盘是否满，cpu 使用率，内存使用率，服务运行状态，是否需要新增或者移除服务器，避免过载或者资源浪费</li>
<li>服务器自动部署，自动装机配置环境<br> 减少运维重复的工作并且提高可靠性，也需要 CMDB 作为基础服务</li>
</ol>
<h2 id="CMDB-系统的组成"><a href="#CMDB-系统的组成" class="headerlink" title="CMDB 系统的组成"></a>CMDB 系统的组成</h2><p>1 用户管理，记录测试，开发，运维人员的用户表</p>
<p>2：业务线管理，需要记录业务的详情</p>
<p>3：项目管理，指定此项目需属于那条业务线，以及项目详情</p>
<p>4：应用管理，指定此应用的开发人员，属于哪个项目，和代码地址，部署目录，部署集群，依赖的应用，软件等信息。</p>
<p>5：主机管理，包括云主机，物理机，主机属于哪个集群，运行着哪些软件，主机管理员，连接着哪些网络设备，云主机的资源地，存储等相关信息。</p>
<p>6：主机变更管理，主机的一些信息变更，例如管理员，所属集群等信息更改，连接的网络变更等。</p>
<p>7：网络设备管理，主要记录网络设备的详细信息，及网络设备连接的上级设备</p>
<p>8：IP 管理，IP 属于哪个主机，哪个网段，是否被占用等</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>记录一个annimate.css的问题</title>
    <url>/2022/01/10/annimate-css/</url>
    <content><![CDATA[<h2 id="annimate-css版本4-1-1在某些电脑上无法显示动画效果"><a href="#annimate-css版本4-1-1在某些电脑上无法显示动画效果" class="headerlink" title="annimate.css版本4.1.1在某些电脑上无法显示动画效果"></a>annimate.css版本4.1.1在某些电脑上无法显示动画效果</h2><ol>
<li>排查问题，浏览器没有报错，不同的浏览器内核也没有差异，只是某些同事的电脑可以显示某些同事的电脑不能显示。</li>
<li>估计可能是操作系统设置的问题，查看不能显示的同事的系统设置，发现在性能设置中关闭了显示窗口内动画效果选项。</li>
<li>方案<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可搜索 外观与性能 或</span><br><span class="line">win+R %windir%\system32\SystemPropertiesPerformance.exe</span><br></pre></td></tr></table></figure>
在视觉效果中勾选窗口内的动画空间和元素，即可</li>
<li>了解到annimate之前的版本无此问题，是在4.0之后的版本出现。将版本回退问题解决</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>antv g2 plot 动态生成报表设计方案</title>
    <url>/2021/08/16/antvg2/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标实现一个大数据统计平台，最终目标是实现一个动态报表，可以选择图表类型，拖拽缩放，自定义布局。可视化操作数据报表，类似阿里云后台的数据管理系统。</p>
<h2 id="开源技术选择"><a href="#开源技术选择" class="headerlink" title="开源技术选择"></a>开源技术选择</h2><ul>
<li>可视化图表的选择，比较了echart，chart.js，antvg2。觉得antv的文档更加友善。开发效率更  好。测试过数据量，10000条数据的柱形图性能影响极小，所以选择antvg2为可视化图表库。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @antv/g2</span><br><span class="line">$ yarn add @antv/g2</span><br></pre></td></tr></table></figure></li>
<li>要实现可视化自定义报表，缩放，拖拽都是必要的，比起自己造轮子有成熟的插件效率更高就没有选择自己写，因为项目的技术栈是vue3.0+ts，所以选择使用<a href="https://github.com/a7650/vue3-draggable-resizable">Vue3DraggableResizable</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install vue3-draggable-resizable</span><br><span class="line">$ yarn add vue3-draggable-resizable</span><br></pre></td></tr></table></figure>
<h2 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h2></li>
<li>使用antvg2plot<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Vue3DraggableResizable</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:initW</span>=<span class="string">&quot;150&quot;</span> <span class="attr">:initH</span>=<span class="string">&quot;150&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">v-model:x</span>=<span class="string">&quot;dadad.x&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model:y</span>=<span class="string">&quot;dadad.y&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-model:w</span>=<span class="string">&quot;dadad.w&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model:h</span>=<span class="string">&quot;dadad.h&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-model:active</span>=<span class="string">&quot;dadad.active&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">:resizable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:parent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">resizing</span>=<span class="string">&#x27;resizeStartHandle&#x27;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container1&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;width: + dadad.w+ &#x27;px&#x27;,height:+dadad.h+&#x27;px&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Vue3DraggableResizable</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Select</span> <span class="attr">style</span>=<span class="string">&quot;width: 120px&quot;</span> <span class="attr">:options</span>=<span class="string">&quot;chartdata&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;change&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Select</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue3DraggableResizable</span> <span class="keyword">from</span> <span class="string">&#x27;vue3-draggable-resizable&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vue3-draggable-resizable/dist/Vue3DraggableResizable.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Line</span>,<span class="title class_">Column</span>,<span class="title class_">Bar</span>,<span class="title class_">Pie</span>  &#125; <span class="keyword">from</span> <span class="string">&#x27;@antv/g2plot&#x27;</span>;</span><br><span class="line"> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//定义拖动数据</span></span><br><span class="line">    <span class="keyword">var</span> movedata =<span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">h</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">w</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">active</span>: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//图表数据</span></span><br><span class="line">    <span class="keyword">var</span> data = [</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">value</span>: <span class="number">4</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;3&#x27;</span>, <span class="attr">value</span>: <span class="number">3.5</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;4&#x27;</span>, <span class="attr">value</span>: <span class="number">5</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;5&#x27;</span>, <span class="attr">value</span>: <span class="number">4.9</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;6&#x27;</span>, <span class="attr">value</span>: <span class="number">6</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;7&#x27;</span>, <span class="attr">value</span>: <span class="number">7</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;8&#x27;</span>, <span class="attr">value</span>: <span class="number">9</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;9&#x27;</span>, <span class="attr">value</span>: <span class="number">13</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;10&#x27;</span>, <span class="attr">value</span>: <span class="number">53</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;11&#x27;</span>, <span class="attr">value</span>: <span class="number">13</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">month</span>: <span class="string">&#x27;12&#x27;</span>, <span class="attr">value</span>: <span class="number">123</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换图表select数据</span></span><br><span class="line">    <span class="keyword">const</span> chartdata=[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="title class_">Line</span>,</span><br><span class="line">        <span class="attr">label</span>:<span class="string">&quot;折线&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="title class_">Column</span>,</span><br><span class="line">        <span class="attr">label</span>:<span class="string">&quot;柱状图&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="title class_">Bar</span>,</span><br><span class="line">        <span class="attr">label</span>:<span class="string">&quot;条形图&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="title class_">Pie</span> ,</span><br><span class="line">        <span class="attr">label</span>:<span class="string">&quot;饼图&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//修改大小后改变图表尺寸</span></span><br><span class="line">    <span class="keyword">const</span> resizeStartHandle =<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">      dadad.<span class="property">w</span>=e.<span class="property">w</span>;</span><br><span class="line">      dadad.<span class="property">h</span>=e.<span class="property">h</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">var</span> line = <span class="title function_">ref</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//mounted之后首次绘制图表，因为在模板没有渲染完成找不到dom节点去挂载实例，只能在mounted之后首次挂载</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       line.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">Line</span>(<span class="string">&#x27;container1&#x27;</span>, &#123;</span><br><span class="line">        data,</span><br><span class="line">        <span class="attr">xField</span>: <span class="string">&#x27;month&#x27;</span>,</span><br><span class="line">        <span class="attr">yField</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      line.<span class="property">value</span>.<span class="title function_">render</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//select方法改变图表</span></span><br><span class="line">  <span class="keyword">const</span> change = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">    line.<span class="property">value</span>.<span class="title function_">destroy</span>()</span><br><span class="line">    line.<span class="property">value</span> = <span class="keyword">new</span> <span class="title function_">val</span>(<span class="string">&#x27;container1&#x27;</span>, &#123;</span><br><span class="line">        data,</span><br><span class="line">        <span class="attr">xField</span>: <span class="string">&#x27;month&#x27;</span>,</span><br><span class="line">        <span class="attr">yField</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      line.<span class="property">value</span>.<span class="title function_">render</span>()</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      chartdata,</span><br><span class="line">      <span class="comment">// line,</span></span><br><span class="line">      change,</span><br><span class="line">      dadad,</span><br><span class="line">      resizeStartHandle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2>实现了根据数据动态选择图表，以及图表的移动，缩放。<br>问题：</li>
<li>以构造函数作为对象字段不合理，这样前后端交互时无法保存数据。</li>
<li>数据结构不合理，图表的长宽以及位置数据应该是跟图表在同一个对象。</li>
<li>动态生成图表，不同图表展示的数据，参数都不同，这里需要再多考虑优化。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p> 基本流程跑通了，antv和Vue3DraggableResizable能满足动态报表生成的基本需求。之后要对表单的数据结构以及图表的切换再继续做优化。
 </p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>bug</title>
    <url>/2021/09/01/bug/</url>
    <content><![CDATA[<h3 id="bug记录"><a href="#bug记录" class="headerlink" title="bug记录"></a>bug记录</h3><ul>
<li><p>vite+vue3.0+antdv。按需引入组件时，代码运行没问题，打包报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123; <span class="title class_">Card</span> ,<span class="title class_">Dropdown</span>,<span class="title class_">Menu</span>,<span class="title class_">MenuItem</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span></span><br><span class="line"> <span class="title class_">Rollup</span> failed to resolve <span class="keyword">import</span> <span class="string">&quot;/XX/XX/XXX&quot;</span> <span class="keyword">from</span> <span class="string">&quot;src/XXX.vue&quot;</span>.</span><br><span class="line"><span class="title class_">This</span> is most likely unintended because it can <span class="keyword">break</span> your application at runtime.</span><br><span class="line"><span class="title class_">If</span> you <span class="keyword">do</span> want to externalize <span class="variable language_">this</span> <span class="variable language_">module</span> explicitly add it to</span><br><span class="line"><span class="string">`build.rollupOptions.external`</span></span><br></pre></td></tr></table></figure>
<p>报错原因:rollup本身不具备解析能力,<br>解决方案：1.不在imprort中引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">components</span>: &#123;</span><br><span class="line">     <span class="title class_">Menu</span>,</span><br><span class="line">     <span class="title class_">MenuItem</span>: <span class="title class_">Menu</span>.<span class="property">Item</span></span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
<p>使用rollup/plugin-alias配置vite.config.ts，未测试，待验证。</p>
</li>
<li><p>同事反应在登录时会出现 Failed to fetch dynamically imported module: xxx.js的报错<br>通过了解，该问题出现在每次版本迭代之后的第一次使用，刷新浏览器即可正常访问，本来想的是可能是浏览器缓存的问题，但是vite打包的资源是加了hash值的，去静态资源里查找并没有找到这个报错的文件，然后发现所有的静态资源都是hash打包，只有index.html没有，与之前的文件名相同。判断是index.html中的缓存请求了之前的静态资源导致了报错。<br>尝试修改nginx配置，默认index.html不缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = /index.html &#123;</span><br><span class="line">   add_header Cache-Control &quot;no-cache, no-store&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试重新打包，问题解决</p>
</li>
<li><p>双斜杠正则表达式在safari浏览器中报语法错误的问题</p>
</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> regExp = <span class="regexp">/XXX/g</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> regExp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(“<span class="variable constant_">XXX</span>”, ‘g’);</span><br></pre></td></tr></table></figure>


<ul>
<li>浏览器兼容scorll-bar的问题<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>:scroll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span>::-webket-scrollbar&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该方案不能兼容firfox和ie10正确的写法是<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>:scroll;</span><br><span class="line">  <span class="attribute">scrollbar-width</span>:none;//兼容firfox</span><br><span class="line">  -ms-<span class="attribute">overflow</span>-style:nene;//兼容ie10</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span>::-webket-scrollbar&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>generator</title>
    <url>/2021/08/11/generator/</url>
    <content><![CDATA[<h3 id="es6的generator函数"><a href="#es6的generator函数" class="headerlink" title="es6的generator函数"></a>es6的generator函数</h3><p>遇到一个需求，要遍历两个树结构，找出其中相同的字段，并且标记。本来图快直接暴力递归，之后觉得不合理，双重循环加递归时间复杂度太高。想优化单独提取字段之后再去重。想到了es6有一个generator函数，写法很优雅，尝试了一下，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">sort</span>(<span class="params">tree: treetabledata</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> tree) &#123;</span><br><span class="line">       <span class="keyword">if</span>(item.<span class="property">component</span> == <span class="string">&#x27;LAYOUT&#x27;</span>&amp;&amp;item.<span class="property">children</span>)</span><br><span class="line">            <span class="keyword">yield</span>* <span class="title function_">sort</span>(item.<span class="property">children</span>)</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">yield</span> item.<span class="property">menuId</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="keyword">const</span> list1 = [...<span class="title function_">sort</span>(treeData3.<span class="property">result</span>.<span class="property">menus</span>)]</span><br><span class="line">     <span class="keyword">const</span> list2 = [...<span class="title function_">sort</span>(treeData1.<span class="property">result</span>.<span class="property">list</span>)]</span><br><span class="line">     <span class="keyword">const</span> list =  [...<span class="keyword">new</span> <span class="title class_">Set</span>(list1.<span class="title function_">concat</span>(list2))]</span><br></pre></td></tr></table></figure>
<p>我认为此处generator函数有两个好处，代码更加简洁易懂，返回的结果是一个遍历器，可以使用拓展运算符或者解构，更加灵活。</p>
<p>之前用genertor函数用的很少，之后又去重新了解了一下。</p>
<ul>
<li>基本概念：Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</li>
</ul>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<ul>
<li>yield表达式：由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</li>
</ul>
<p>遍历器对象的next方法的运行逻辑如下。</p>
<p>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p>
<p>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p>
<p>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p>
<p>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
<ul>
<li>next指调用此方法，内部指针指向该语句时才会执行，我选择了使用for of循环，可以不用使用next方法拿到yield的状态。</li>
<li>在genertor内部继续调用genertor函数：像上面的代码一样，使用yield*加genertor函数，实现递归。</li>
</ul>
<p>genertor的应用场景比较适合流程管理和状态管理。我的用法就显得很肤浅，没有遇到过类似的业务，希望以后能有机会碰到，关于genertor函数的学习也只到使用，并没有往原型链，返回的遍历器类型上深究，之后有机会会慢慢补充</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>cocos</title>
    <url>/2022/07/04/cocos/</url>
    <content><![CDATA[<h3 id="关于最近cocos学习的记录"><a href="#关于最近cocos学习的记录" class="headerlink" title="关于最近cocos学习的记录"></a>关于最近cocos学习的记录</h3><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ul>
<li>预制体：在编辑器中整合资源同步使用节点，必须有一个根节点，只有根节点之下的元素会被保存，内置的组件，有sprit，label,button,layout等常用</li>
<li>脚本：使用ts编辑的脚本，继承cc类，可以在编辑器中绑定在预制体中，当预制体被加载脚本就会执行。</li>
<li>组件：在预制体中添加的组件，分为ui组件，渲染组件,Mesh组件，碰撞组件，物理组件，用户组件，用户脚本组件等，其中用户脚本组件就是我们需要编辑的脚本。</li>
<li>场景：cocos的工作流程是以数据驱动为核心，每个项目都有一个默认场景打开demo在assets文件夹下找到Hello World 默认场景。</li>
<li>动画：目前我接触过的有spine动画，annimation序列帧，一些简单的动效可以在脚本中使用缓动和annimation实现。</li>
</ul>
<h2 id="游戏结构"><a href="#游戏结构" class="headerlink" title="游戏结构"></a>游戏结构</h2><ul>
<li>ui：封装的view方法用于加载不同的场景预制体和panal。</li>
<li>event：事件，通过dispatch和addEventListener，removeEventListener全局管理事件系统</li>
<li>碰撞检测系统，根据cocos的分组碰撞检测，派发事件执行不同的结果</li>
<li>audio：封装cocos内置的音频系统。</li>
<li>避障：没接触，后续有接触再补充。</li>
<li>网络：使用websoket以及json格式的数据交互。</li>
</ul>
<h2 id="脚本的编写"><a href="#脚本的编写" class="headerlink" title="脚本的编写"></a>脚本的编写</h2><ul>
<li>生命周期：onload，脚本加载完成时执行，onDestroy，在脚本销毁时执行。update，每一帧都会执行。</li>
<li>方法：脚本实际上是一个类，类的方法可以在生命周期里执行，可以监听事件执行方法，也可以通过编辑器绑定事件执行。</li>
<li>脚本需要继承cc类才可以在编辑器中改选中绑定到预制体中。</li>
<li>绑定的事件需要再组件销毁之后取消绑定。</li>
<li>一个预制体可以绑定多个不同的脚本，也可以动态添加删除脚本。</li>
</ul>
]]></content>
      <tags>
        <tag>coocs</tag>
      </tags>
  </entry>
  <entry>
    <title>gozero</title>
    <url>/2021/10/13/gozero/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>安装 golang</li>
<li>配置 gomodudle</li>
<li>安装 gotcl</li>
<li>安装 proto 或者 protoc-gen-go</li>
</ul>
<p>因为不是自己搭建的项目，项目相关底层配置暂不熟悉，之后慢慢补充。</p>
<h3 id="搭建微服务步骤，"><a href="#搭建微服务步骤，" class="headerlink" title="搭建微服务步骤，"></a>搭建微服务步骤，</h3><ul>
<li>编辑 api 文件</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">@server(</span><br><span class="line">	group: xxx<span class="comment">//生成文件的分组</span></span><br><span class="line">)</span><br><span class="line">service xxx &#123;</span><br><span class="line">	@handler Getchartlist</span><br><span class="line">	post /xxx/xxx(req) returns(res)<span class="comment">//定义api网关</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span>(</span><br><span class="line">    res&#123;</span><br><span class="line">     A <span class="type">string</span> <span class="string">`json:&quot;a,optional&quot;`</span> <span class="comment">//定义参数和返回值类型 可以引用类型， 首字母非大写代表私有变量，描述字段中定义在json中需要传的字段，前端请求时参数为 a 服务端处理按照 A来取值 optional代表此参数可为空。</span></span><br><span class="line">     B <span class="type">int64</span>  <span class="string">`json:&quot;b,optional&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    req&#123;</span><br><span class="line">    X list  <span class="string">`json:&quot;x,optional&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    list&#123;</span><br><span class="line">     Y <span class="type">string</span> <span class="string">`json:&quot;y,optional&quot;`</span></span><br><span class="line">     Z <span class="type">string</span> <span class="string">`json:&quot;z,optional&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>在主 api 文件中引入新编辑的 api 文件</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;xxx.api&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 goctl 命令编译 api 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ goctl api go -api xxx.api -<span class="built_in">dir</span> . -style goZero</span><br><span class="line">//-dir 需要输出文件的路径  -stlye 输出文件的命名风格</span><br></pre></td></tr></table></figure>

<p>之后会生成如下的文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── etc</span><br><span class="line">│   └── greet-api.yaml              // 配置文件</span><br><span class="line">├── go.mod                          // mod文件</span><br><span class="line">├── greet.api                       // api描述文件</span><br><span class="line">├── greet.go                        // main函数入口</span><br><span class="line">└── internal</span><br><span class="line">    ├── config</span><br><span class="line">    │   └── config.go               // 配置声明type</span><br><span class="line">    ├── handler                     // 路由及handler转发</span><br><span class="line">    │   ├── greethandler.go</span><br><span class="line">    │   └── routes.go</span><br><span class="line">    ├── logic                       // 业务逻辑</span><br><span class="line">    │   └── greetlogic.go</span><br><span class="line">    ├── middleware                  // 中间件文件</span><br><span class="line">    │   └── greetmiddleware.go</span><br><span class="line">    ├── svc                         // logic所依赖的资源池</span><br><span class="line">    │   └── servicecontext.go</span><br><span class="line">    └── types                       // request、response的struct，根据api自动生成，不建议编辑</span><br><span class="line">        └── types.go</span><br></pre></td></tr></table></figure>

<p>其中我们需要关注的是 config 中的配置信息，yaml 文件中的端口，数据库等配置。在 logic 中编写业务逻辑，其他文件根据需求改动。</p>
<ul>
<li>新建 rpc 服务<br>新建一个文件夹用来存放 rpc 服务，在文件夹中新建一个.proto 文件，如果需要连接数据库，可分别新建 model 和 rpc 文件夹<br>在 rpc 文件夹下新建一个.proto 文件编写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Request&#123;//定义信息的req值类型</span><br><span class="line">  int64  A =1;</span><br><span class="line">  string B =2;</span><br><span class="line">&#125;</span><br><span class="line">message Response&#123;//定义信息的res值类型</span><br><span class="line">  int64  X =1;</span><br><span class="line">  string Y =2;</span><br><span class="line">&#125;</span><br><span class="line"> service xxx &#123;</span><br><span class="line"> rpc Ping(Request) returns(Response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 goctl 指令生成 rpc 服务代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ goctl rpc proto -src xxx.proto -<span class="built_in">dir</span> . //与api指令语法类似</span><br></pre></td></tr></table></figure>

<p>生成的 rpc 目录如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── etc             // yaml配置文件</span><br><span class="line">│   └── greet.yaml</span><br><span class="line">├── go.mod</span><br><span class="line">├── greet           // pb.go文件夹①</span><br><span class="line">│   └── greet.pb.go</span><br><span class="line">├── greet.go        // main函数</span><br><span class="line">├── greet.proto     // proto 文件</span><br><span class="line">├── greetclient     // call logic ②</span><br><span class="line">│   └── greet.go</span><br><span class="line">└── internal</span><br><span class="line">   ├── config      // yaml配置对应的实体</span><br><span class="line">   │   └── config.go</span><br><span class="line">   ├── logic       // 业务代码</span><br><span class="line">   │   └── pinglogic.go</span><br><span class="line">   ├── server      // rpc server</span><br><span class="line">   │   └── greetserver.go</span><br><span class="line">   └── svc         // 依赖资源</span><br><span class="line">       └── servicecontext.go</span><br></pre></td></tr></table></figure>
<p>与网关层类似，需要关注的是yaml配置文件，logic业务代码，config，以及svc的依赖资源配置，其他文件由指令生成按需改动。</p>
<ul>
<li><p>生成model文件<br>操作数据库一般在rpc服务中操作，在之前新建的model文件夹下使用goctl生成model文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ goctl model mysql datasource -url=<span class="string">&quot;user:password@tcp(127.0.0.1:3306)/database&quot;</span> -table=<span class="string">&quot;*&quot;</span>  -<span class="built_in">dir</span>=<span class="string">&quot;./model&quot;</span></span><br><span class="line">//推荐使用datasource生成</span><br></pre></td></tr></table></figure>
<p>生成的model文件代码示例</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/tal-tech/go-zero/core/stores/cache&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tal-tech/go-zero/core/stores/sqlc&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tal-tech/go-zero/core/stores/sqlx&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tal-tech/go-zero/core/stringx&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tal-tech/go-zero/tools/goctl/model/sql/builderx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    userFieldNames          = builderx.RawFieldNames(&amp;User&#123;&#125;)</span><br><span class="line">    userRows                = strings.Join(userFieldNames, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    userRowsExpectAutoSet   = strings.Join(stringx.Remove(userFieldNames, <span class="string">&quot;`id`&quot;</span>, <span class="string">&quot;`create_time`&quot;</span>, <span class="string">&quot;`update_time`&quot;</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    userRowsWithPlaceHolder = strings.Join(stringx.Remove(userFieldNames, <span class="string">&quot;`id`&quot;</span>, <span class="string">&quot;`create_time`&quot;</span>, <span class="string">&quot;`update_time`&quot;</span>), <span class="string">&quot;=?,&quot;</span>) + <span class="string">&quot;=?&quot;</span></span><br><span class="line"></span><br><span class="line">    cacheUserNamePrefix   = <span class="string">&quot;cache#User#name#&quot;</span></span><br><span class="line">    cacheUserMobilePrefix = <span class="string">&quot;cache#User#mobile#&quot;</span></span><br><span class="line">    cacheUserIdPrefix     = <span class="string">&quot;cache#User#id#&quot;</span></span><br><span class="line">    cacheUserPrefix       = <span class="string">&quot;cache#User#user#&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    UserModel <span class="keyword">interface</span> &#123;<span class="comment">//默认生成的查询方法，如果有其他需求，需添加方法</span></span><br><span class="line">        Insert(data User) (sql.Result, <span class="type">error</span>)</span><br><span class="line">        FindOne(id <span class="type">int64</span>) (*User, <span class="type">error</span>)</span><br><span class="line">        FindOneByUser(user <span class="type">string</span>) (*User, <span class="type">error</span>)</span><br><span class="line">        FindOneByName(name <span class="type">string</span>) (*User, <span class="type">error</span>)</span><br><span class="line">        FindOneByMobile(mobile <span class="type">string</span>) (*User, <span class="type">error</span>)</span><br><span class="line">        Update(data User) <span class="type">error</span></span><br><span class="line">        Delete(id <span class="type">int64</span>) <span class="type">error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultUserModel <span class="keyword">struct</span> &#123;</span><br><span class="line">        sqlc.CachedConn</span><br><span class="line">        table <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User <span class="keyword">struct</span> &#123;<span class="comment">//查询的表的字段</span></span><br><span class="line">        Id         <span class="type">int64</span>     <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">        User       <span class="type">string</span>    <span class="string">`db:&quot;user&quot;`</span>     <span class="comment">// 用户</span></span><br><span class="line">        Name       <span class="type">string</span>    <span class="string">`db:&quot;name&quot;`</span>     <span class="comment">// 用户名称</span></span><br><span class="line">        Password   <span class="type">string</span>    <span class="string">`db:&quot;password&quot;`</span> <span class="comment">// 用户密码</span></span><br><span class="line">        Mobile     <span class="type">string</span>    <span class="string">`db:&quot;mobile&quot;`</span>   <span class="comment">// 手机号</span></span><br><span class="line">        Gender     <span class="type">string</span>    <span class="string">`db:&quot;gender&quot;`</span>   <span class="comment">// 男｜女｜未公开</span></span><br><span class="line">        Nickname   <span class="type">string</span>    <span class="string">`db:&quot;nickname&quot;`</span> <span class="comment">// 用户昵称</span></span><br><span class="line">        CreateTime time.Time <span class="string">`db:&quot;create_time&quot;`</span></span><br><span class="line">        UpdateTime time.Time <span class="string">`db:&quot;update_time&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserModel</span><span class="params">(conn sqlx.SqlConn, c cache.CacheConf)</span></span> UserModel &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;defaultUserModel&#123;</span><br><span class="line">        CachedConn: sqlc.NewConn(conn, c),</span><br><span class="line">        table:      <span class="string">&quot;`user`&quot;</span>,<span class="comment">//当前查询的表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> Insert(data User) (sql.Result, <span class="type">error</span>) &#123;</span><br><span class="line">    userNameKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserNamePrefix, data.Name)</span><br><span class="line">    userMobileKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserMobilePrefix, data.Mobile)</span><br><span class="line">    userKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserPrefix, data.User)</span><br><span class="line">    ret, err := m.Exec(<span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn)</span></span> (result sql.Result, err <span class="type">error</span>) &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;insert into %s (%s) values (?, ?, ?, ?, ?, ?)&quot;</span>, m.table, userRowsExpectAutoSet)</span><br><span class="line">        <span class="keyword">return</span> conn.Exec(query, data.User, data.Name, data.Password, data.Mobile, data.Gender, data.Nickname)</span><br><span class="line">    &#125;, userNameKey, userMobileKey, userKey)</span><br><span class="line">    <span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> FindOne(id <span class="type">int64</span>) (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    userIdKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserIdPrefix, id)</span><br><span class="line">    <span class="keyword">var</span> resp User</span><br><span class="line">    err := m.QueryRow(&amp;resp, userIdKey, <span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;select %s from %s where `id` = ? limit 1&quot;</span>, userRows, m.table)</span><br><span class="line">        <span class="keyword">return</span> conn.QueryRow(v, query, id)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;resp, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> sqlc.ErrNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotFound</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> FindOneByUser(user <span class="type">string</span>) (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    userKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserPrefix, user)</span><br><span class="line">    <span class="keyword">var</span> resp User</span><br><span class="line">    err := m.QueryRowIndex(&amp;resp, userKey, m.formatPrimary, <span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn, v <span class="keyword">interface</span>&#123;&#125;)</span></span> (i <span class="keyword">interface</span>&#123;&#125;, e <span class="type">error</span>) &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;select %s from %s where `user` = ? limit 1&quot;</span>, userRows, m.table)</span><br><span class="line">        <span class="keyword">if</span> err := conn.QueryRow(&amp;resp, query, user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp.Id, <span class="literal">nil</span></span><br><span class="line">    &#125;, m.queryPrimary)</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;resp, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> sqlc.ErrNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotFound</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> FindOneByName(name <span class="type">string</span>) (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    userNameKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserNamePrefix, name)</span><br><span class="line">    <span class="keyword">var</span> resp User</span><br><span class="line">    err := m.QueryRowIndex(&amp;resp, userNameKey, m.formatPrimary, <span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn, v <span class="keyword">interface</span>&#123;&#125;)</span></span> (i <span class="keyword">interface</span>&#123;&#125;, e <span class="type">error</span>) &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;select %s from %s where `name` = ? limit 1&quot;</span>, userRows, m.table)</span><br><span class="line">        <span class="keyword">if</span> err := conn.QueryRow(&amp;resp, query, name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp.Id, <span class="literal">nil</span></span><br><span class="line">    &#125;, m.queryPrimary)</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;resp, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> sqlc.ErrNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotFound</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> FindOneByMobile(mobile <span class="type">string</span>) (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    userMobileKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserMobilePrefix, mobile)</span><br><span class="line">    <span class="keyword">var</span> resp User</span><br><span class="line">    err := m.QueryRowIndex(&amp;resp, userMobileKey, m.formatPrimary, <span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn, v <span class="keyword">interface</span>&#123;&#125;)</span></span> (i <span class="keyword">interface</span>&#123;&#125;, e <span class="type">error</span>) &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;select %s from %s where `mobile` = ? limit 1&quot;</span>, userRows, m.table)</span><br><span class="line">        <span class="keyword">if</span> err := conn.QueryRow(&amp;resp, query, mobile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp.Id, <span class="literal">nil</span></span><br><span class="line">    &#125;, m.queryPrimary)</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;resp, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> sqlc.ErrNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotFound</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> Update(data User) <span class="type">error</span> &#123;</span><br><span class="line">    userIdKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserIdPrefix, data.Id)</span><br><span class="line">    _, err := m.Exec(<span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn)</span></span> (result sql.Result, err <span class="type">error</span>) &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;update %s set %s where `id` = ?&quot;</span>, m.table, userRowsWithPlaceHolder)</span><br><span class="line">        <span class="keyword">return</span> conn.Exec(query, data.User, data.Name, data.Password, data.Mobile, data.Gender, data.Nickname, data.Id)</span><br><span class="line">    &#125;, userIdKey)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> Delete(id <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    data, err := m.FindOne(id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userNameKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserNamePrefix, data.Name)</span><br><span class="line">    userMobileKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserMobilePrefix, data.Mobile)</span><br><span class="line">    userIdKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserIdPrefix, id)</span><br><span class="line">    userKey := fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserPrefix, data.User)</span><br><span class="line">    _, err = m.Exec(<span class="function"><span class="keyword">func</span><span class="params">(conn sqlx.SqlConn)</span></span> (result sql.Result, err <span class="type">error</span>) &#123;</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;delete from %s where `id` = ?&quot;</span>, m.table)</span><br><span class="line">        <span class="keyword">return</span> conn.Exec(query, id)</span><br><span class="line">    &#125;, userNameKey, userMobileKey, userIdKey, userKey)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> formatPrimary(primary <span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s%v&quot;</span>, cacheUserIdPrefix, primary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultUserModel)</span></span> queryPrimary(conn sqlx.SqlConn, v, primary <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    query := fmt.Sprintf(<span class="string">&quot;select %s from %s where `id` = ? limit 1&quot;</span>, userRows, m.table)</span><br><span class="line">    <span class="keyword">return</span> conn.QueryRow(v, query, primary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，在rpc/imternal/svc下的资源管理文件中注册model方法</p>
</li>
<li><p>编写logic中的业务代码<br>首先在rpc/internal/logic中找到之前生成的文件</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *PingLogic)</span></span> Ping(in *chart.Request) (*xxx.Response, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// todo: add your logic here and delete this line</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;xxx.Response&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在此处编写业务逻辑代码，调用model方法查询数据，返回，类型是之前编写的.proto文件中定义的返回值数据类型</span></span><br></pre></td></tr></table></figure>
<p>之后在网关层internal/logic中编写网关层的逻辑代码</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *xxx)</span></span> ApiLogin(req types.RegisterAndLogin) (*types.xxxx, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// todo: add your logic here and delete this line</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;types.xxx&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">    <span class="comment">//此处编写网关层的业务代码，类型为之前编写的.api文件的数据类型。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编译，每个prc服务根目录下有xx.go文件需要单独起服务，注意不要端口重复，互相依赖的服务需先启动被依赖的服务。一个gozero微服务就完成了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang结构体</title>
    <url>/2021/09/26/golangstruct/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>golang 中没有类的概念，所以使用结构体来达到面向对象的目的。类似于 typescript 的 interfece，golang 为强类型语言，每个值的引用，函数的参数及返回值都必须定义结构体规范数据类型。</li>
<li>成员变量：golang 中没有 public 和 private 关键字，定义私有变量和公共变量的方法是首字母的大小写区分</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hour <span class="type">int</span>    <span class="comment">//公共变量</span></span><br><span class="line">    minute <span class="type">int</span>  <span class="comment">//私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体的使用流程"><a href="#结构体的使用流程" class="headerlink" title="结构体的使用流程"></a>结构体的使用流程</h2><ul>
<li>定义结构体</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">	size, price <span class="type">float64</span></span><br><span class="line">	style <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基本实例化</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h1 house</span><br><span class="line">h1.size = <span class="number">130</span></span><br><span class="line">h1.style = <span class="string">&quot;中国风&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, h1) <span class="comment">// &#123;130 0 中国风&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, h1)  <span class="comment">// main.house&#123;size:130, price:0, style:&quot;中国风&quot;&#125;</span></span><br><span class="line">fmt.Println(h1.size)   <span class="comment">// 130</span></span><br></pre></td></tr></table></figure>
<ul>
<li>匿名的结构体（匿名的结构体可以定义临时结构体）<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> family <span class="keyword">struct</span> &#123;</span><br><span class="line">	Mom <span class="type">string</span></span><br><span class="line">	Dad <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">family.Mom = <span class="string">&quot;Mommy&quot;</span></span><br><span class="line">family.Dad = <span class="string">&quot;Daddy&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, family)  <span class="comment">// &#123;Mommy Daddy&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, family) <span class="comment">// struct &#123; Mom string; Dad string &#125;&#123;Mom:&quot;Mommy&quot;, Dad:&quot;Daddy&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>结构体指针<br>使用new关键字<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(house)</span><br><span class="line">p1.style = <span class="string">&quot;欧式&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// &amp;main.house&#123;size:0, price:0, style:&quot;欧式&quot;&#125;</span></span><br></pre></td></tr></table></figure>
使用地址符&amp;<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p2 := &amp;house&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)  <span class="comment">// *main.house</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p2) <span class="comment">// &amp;main.house&#123;size:0, price:0, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>构造函数<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">	size, price <span class="type">float64</span></span><br><span class="line">	style       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 返回结构体指针</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHouse</span><span class="params">(size, price <span class="type">float64</span>, style <span class="type">string</span>)</span></span> *house &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;house&#123;</span><br><span class="line">		size:  size,</span><br><span class="line">		price: price,</span><br><span class="line">		style: style,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := newHouse(<span class="number">100</span>, <span class="number">80</span>, <span class="string">&quot;中国风&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// &amp;main.house&#123;size:100, price:80, style:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="golang的指针-amp-和"><a href="#golang的指针-amp-和" class="headerlink" title="golang的指针 &amp;和*"></a>golang的指针 &amp;和*</h2>经常会见到: p . <em>p , &amp;p 三个符号<br>p是一个指针变量的名字，表示此指针变量指向的内存地址，如果使用%p来输出的话，它将是一个16进制数。而</em>p表示此指针指向的内存地址中存放的内容，一般是一个和指针类型一致的变量或者常量。<br>而我们知道，&amp;是取地址运算符，&amp;p就是取指针p的地址。等会，怎么又来了个地址，它到底和p有什么区别？区别在于，指针p同时也是个变量，既然是变量，编译器肯定要为其分配内存地址，就像程序中定义了一个int型的变量i，编译器要为其分配一块内存空间一样。而&amp;p就表示编译器为变量p分配的内存地址，而因为p是一个指针变量，这种特殊的身份注定了它要指向另外一个内存地址，程序员按照程序的需要让它指向一个内存地址，这个它指向的内存地址就用p表示。而且，p指向的地址中的内容就用*p表示。</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>windows配置golang环境</title>
    <url>/2021/08/09/gozerolern/</url>
    <content><![CDATA[<ol>
<li><a href="https://studygolang.com/dl">官网</a>下载golang</li>
<li>环境配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOPATH: //go 的工作目录</span><br><span class="line">GOROOT：//go 的安装目录</span><br><span class="line">GOBIN：//go 的bin文件目录</span><br><span class="line">GO111MODULE： //go mod 开关 on为开启go mod</span><br><span class="line">GOPROXY=https://goproxy.cn,direct // https://goproxy.cn,direct 国内代理</span><br></pre></td></tr></table></figure></li>
<li>GOPATH:早期golang的依赖管理方式，配置bin src packege三个文件夹，src下存放项目，bin存放第三方库，package存放包。之后有go mod之后这种方式就很少使用了。</li>
<li>go mod:go mod可以完全替代GOPATH设置。只需要go env -w GO111MODULE=on开启go mod<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod init myproject</span><br></pre></td></tr></table></figure>
会生成一个go.mod文件作为依赖人口文件，在之后新引入的模块可以使用绝对路径来获取。不需要在将项目放在GOPATH下的src目录下。<br>更新依赖<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod tidy</span><br></pre></td></tr></table></figure></li>
<li>其他一些用到过的命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run xxx //运行当前文件</span><br><span class="line">$ go build xxx //编译当前文件为一个可执行的.exe文件</span><br><span class="line">$ go get xxx //获取远程资源，存放在GOPATH的bin或者package文件夹下取决去拉取的文件是否可以执行</span><br><span class="line">$ go install  生成可执行文件。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用hexo在github上搭建个人博客</title>
    <url>/2021/08/09/hexo/</url>
    <content><![CDATA[<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p> 安装 <a href="https://hexo.io/docs/">hexo</a>需要node环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>新建hexo项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>在heox主页找到自己喜欢的模板，download，将文件夹放在新搭建的博客中的themes文件夹下。<br>将根目录的_config.yml文件设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme</span>: diaspora</span><br></pre></td></tr></table></figure>
<p>如何新建博客，如何使用分类和标签,参考官方文档和主题reademe文件</p>
<h3 id="生成静态资源"><a href="#生成静态资源" class="headerlink" title="生成静态资源"></a>生成静态资源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate </span><br></pre></td></tr></table></figure>
<h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>默认端口为4000</p>
<h3 id="如何在github上搭建博客"><a href="#如何在github上搭建博客" class="headerlink" title="如何在github上搭建博客"></a>如何在github上搭建博客</h3><p> <a href="https://zhuanlan.zhihu.com/p/28321740">参考知乎</a>由于hexo项目需要编译成静态资源才能被github.io识别，所以建议新建两个仓库将hexo项目设定为privite。或者可以在io下新建子分支。</p>
<h3 id="本地打包上传"><a href="#本地打包上传" class="headerlink" title="本地打包上传"></a>本地打包上传</h3><p>需要在根目录下配置仓库地址，更多配置参考官方文档</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="comment">#上传方式</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment">#你的github仓库地址</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">address</span></span><br><span class="line">  <span class="comment">#分支名</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy </span><br></pre></td></tr></table></figure>
<p>之后访问 username.github.io就可以看到个人博客了。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>hexo的整体配置例如仓库地址，主题，端口等在根目录下的_config.yml文件。而样式配置例如路径，图片，标题等，在主题内部的_config.yml文件下配置。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>js的new关键字实现</title>
    <url>/2022/10/11/howNew/</url>
    <content><![CDATA[<h2 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h2><ul>
<li>创建一个新的对象</li>
<li>添加弗雷属性到新对象并且初始化</li>
<li>继承父类原型方法，初始化，保存方法的执行结果</li>
<li>如果执行结果有返回值并且为一个对象，返回结果，否则返回新创建的对象</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">obj, ...rest</span>)&#123;</span><br><span class="line">  <span class="comment">// 基于obj的原型创建一个新的对象</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到新创建的newObj上, 并获取obj函数执行的结果.</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">apply</span>(newObj, rest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>华为OD面试</title>
    <url>/2021/11/29/huaweiOdinterview/</url>
    <content><![CDATA[<h2 id="一面机试三道题"><a href="#一面机试三道题" class="headerlink" title="一面机试三道题"></a>一面机试三道题</h2><ol>
<li>100个人围成一个圈，输入一个树报数，报到该数字的人退出，球最后剩下的人的编号。约瑟夫环</li>
<li>给定一串不等式的输入，求不等式是否成立，如不成立输出不等式的最大值。</li>
<li>给定一串服务之间的依赖关系以及服务总数，求当其中某些服务出问题之后，哪些服务依旧能正常运行</li>
</ol>
<h2 id="二面性格测试"><a href="#二面性格测试" class="headerlink" title="二面性格测试"></a>二面性格测试</h2><h2 id="三面技术"><a href="#三面技术" class="headerlink" title="三面技术"></a>三面技术</h2><ol>
<li>笔试题，将一组字符串按照其中字符出现的次数降序排序。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码题目：</span></span><br><span class="line"><span class="comment">// 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</span></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="comment">// 输入: &quot;tree&quot;，输出: &quot;eert&quot;</span></span><br><span class="line"><span class="comment">// 解释: &#x27;e&#x27;出现两次，&#x27;r&#x27;和&#x27;t&#x27;都只出现一次。因此&#x27;e&#x27;必须出现在&#x27;r&#x27;和&#x27;t&#x27;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line"><span class="comment">// 输入:&quot;cccaaa&quot;，输出:&quot;cccaaa&quot;</span></span><br><span class="line"><span class="comment">// 解释:&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span></span><br><span class="line"><span class="comment">// 示例 3:</span></span><br><span class="line"><span class="comment">// 输入:&quot;Aabb&quot;，输出:&quot;bbAa&quot;</span></span><br><span class="line"><span class="comment">// 解释:此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortstr</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> arr1 = []</span><br><span class="line">    <span class="keyword">let</span> newstr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[item]) &#123;</span><br><span class="line">            obj[item] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            obj[item] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        arr1.<span class="title function_">push</span>([item, obj[item]])</span><br><span class="line">    &#125;)</span><br><span class="line">    arr1.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    arr1.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; item[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">            newstr += item[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newstr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortstr</span>(<span class="string">&#x27;cccaaa&#x27;</span>), <span class="title function_">sortstr</span>(<span class="string">&#x27;tree&#x27;</span>), <span class="title function_">sortstr</span>(<span class="string">&#x27;Aabb&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li>闭包的使用场景。</li>
<li>遇到过什么问题，怎么解决的。</li>
<li>是怎样接触到前端的，是怎么学习的。</li>
<li>一些简单的技术问题，记不清了</li>
</ol>
<h2 id="四面技术"><a href="#四面技术" class="headerlink" title="四面技术"></a>四面技术</h2><ol>
<li>笔试题，将一个数组向前移动一位，第一位到最后一位，输入一个number参数，决定执行多少次。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeArr</span>(<span class="params">arr,key</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> length=arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">let</span> time= key%length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line">     arr.<span class="title function_">pop</span>()</span><br><span class="line">     arr.<span class="title function_">unshift</span>(target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">changeArr</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">10002</span>))</span><br></pre></td></tr></table></figure></li>
<li>一样的遇到过什么问题，怎么解决的。</li>
<li>作用域链。</li>
<li>用到过的去重方法。</li>
<li>vue router的原理。</li>
<li>ts的泛型。public和privite的区别。</li>
<li>es6的proxy</li>
<li>es6的Object.keys和es的for in有什么区别</li>
<li>深浅拷贝，json方法有什么缺点</li>
</ol>
<h2 id="五面主管"><a href="#五面主管" class="headerlink" title="五面主管"></a>五面主管</h2><ol>
<li>你认为这份工作对你意味着什么</li>
<li>你对自己怎么评价</li>
</ol>
<h2 id="六面HR面"><a href="#六面HR面" class="headerlink" title="六面HR面"></a>六面HR面</h2>]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>jsxinvue</title>
    <url>/2021/12/07/jsxinvue/</url>
    <content><![CDATA[<h2 id="总结一些在vue3-0中使用tsx遇到的问题"><a href="#总结一些在vue3-0中使用tsx遇到的问题" class="headerlink" title="总结一些在vue3.0中使用tsx遇到的问题"></a>总结一些在vue3.0中使用tsx遇到的问题</h2><ul>
<li>与模板的不同</li>
</ul>
<ol>
<li>在模板语法中setup最终会return一个对象，对象中的属性是setup暴露给模板使用的当return中未定义属性，会报错，在tsx中return类似一个render函数，返回虚拟dom，在使用数据室如果是ref型数据需带上value。</li>
<li>无法使用v-on语法糖，@也无法绑定的事件，需使用on+事件名的方法绑定事件，事件名首字母需定义为小写，在使用时大写，表现成驼峰命名。</li>
<li>无法使用v-if或者v-else语法糖，应该遵循jsx的规范使用三目运算符达到v-if的效果</li>
<li>无法使用：/v-bind绑定数据,应该写成data={value}的形式</li>
<li>所有的变量使用必须用{}包裹起来</li>
<li>v-model的写法为v-model:value={data}的形式，文档上有其他的写法，暂时没有用到</li>
<li>绑定的事件应该为onClick={eventname}的形式如果直接以代码的形式应该为onClick={()=&gt;event}的形式</li>
<li>插槽的使用，应该使用v-slots代替v-slot<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">A</span> = (<span class="params">props, &#123; slots &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; slots.default ? slots.default() : &#x27;foo&#x27; &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; slots.bar?.() &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> slots = &#123;</span><br><span class="line">      <span class="attr">bar</span>: <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">A</span> <span class="attr">v-slots</span>=<span class="string">&#123;slots&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> slots = &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">A</span> <span class="attr">v-slots</span>=<span class="string">&#123;slots&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;&#123;</span></span><br><span class="line"><span class="language-xml">            default: () =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">            bar: () =&gt; <span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">B</span>&gt;</span>&#123;() =&gt; &quot;foo&quot;&#125;<span class="tag">&lt;/<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>v-show可以正常使用为v-show={boolean}</li>
<li>其他问题暂未遇到</li>
</ol>
<ul>
<li>bug</li>
</ul>
<ol>
<li>vitejs/plugin-vue-jsx插件 1.1.5版本不支持vue-next-jsx中的v-model语法糖升级到1.3.0解决</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>proxy和Reflect</title>
    <url>/2021/08/12/proxy/</url>
    <content><![CDATA[<p>  vue3.0在双向绑定上做了优化，从Object.defineproperty换成了proxy。这样解决了之前对与数组中某个属性的新增和删除无法监听，计算量大，影响新能，深度监听操作复杂等问题。<br>proxy:顾名思义代理，让我们访问对象的时候不需要直接访问对象地址，而是由proxy替我们完成。它可以劫持整个对象，并且返回一个新的对象。这里我去百度了一下代理模式和mdn对proxy的解释。</p>
<ul>
<li>什么是代理模式<br>代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。<br>所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。<br>著名的代理模式例子为引用计数（英语：reference counting）指针对象。<br>当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</li>
<li>什么是proxy对象<br>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。<br>简单来说:Proxy对象就是可以让你去对JavaScript中的一切合法对象的基本操作进行自定义.然后用你自定义的操作去覆盖其对象的基本操作.也就是当一个对象去执行一个基本操作时,其执行的过程和结果是你自定义的,而不是对象的.<br>proxy的基本使用：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, name</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="string">&#x27;No prop!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">p.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">a</span>);    <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">b</span>);    <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">c</span>);    <span class="comment">//No prop!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
其中hander的回调函数共有13种拦截</li>
<li>getPrototypeOf(可以拦截取对象的原型对象的行为)</li>
<li>setPrototypeOf(可以拦截变更对象的原型对象的行为)</li>
<li>isExtensible(可以拦截判断对象是否可扩展（即是否能追加新属性）的行为)</li>
<li>preventExtensions(可以拦截阻止对象被扩展（即不能为对象增加新属性，但是既有属性的值仍然可以更改，也可以把属性删除）的行为：)</li>
<li>ownKeys (可以拦截获取属性名的行为)</li>
<li>getOwnPropertyDescriptor(可以拦截获取自身属性描述的行为)</li>
<li>defineProperty (可以拦截定义属性的行为)</li>
<li>deleteProperty(可以拦截delete行为)</li>
<li>get(可以拦截读取对象属性值的行为)</li>
<li>set (可以拦截修改对象属性值的行为)</li>
<li>has(可以拦截检查是否含有该参数的行为)</li>
<li>apply (以拦截函数调用的行为，包括apply调用，call调用)</li>
<li>construct(可以拦截new命令)</li>
</ul>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p> Proxy自身还有个静态方法Proxy.revocable(target, handler)，用于创建并返回一个可取消的Proxy对象。返回的这个可取消的Proxy对象有两个属性：proxy和revoke</p>
<p>属性proxy会调用new Proxy(target, handler)创建一个新的Proxy对象。属性revoke是一个无参函数，用于取消，即让该Proxy对象无效。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> revocable = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[[&quot;</span> + name + <span class="string">&quot;]]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p = revocable.<span class="property">proxy</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">foo</span>); <span class="comment">// &quot;[[foo]]&quot;</span></span><br><span class="line"></span><br><span class="line">revocable.<span class="title function_">revoke</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">foo</span>);  <span class="comment">//TypeError: illegal operation attempted on a revoked proxy</span></span><br><span class="line">p.<span class="property">foo</span> = <span class="number">1</span>;           <span class="comment">//TypeError: illegal operation attempted on a revoked proxy</span></span><br><span class="line"><span class="keyword">delete</span> p.<span class="property">foo</span>;        <span class="comment">//TypeError: illegal operation attempted on a revoked proxy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> p); <span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<p>示例中Proxy.revocable方法返回一个可取消的Proxy对象。调用该对象的proxy属性得到真实的Proxy对象。如果不想用了，可以调用revoke()方法将该Proxy对象无效化。之后对Proxy对象的任何操作都将抛出异常。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。Reflect对象一共有 13 个静态方法与proxy相同。若需要在Proxy内部调用对象的默认行为，使用Reflect</p>
<ul>
<li>只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在。这些方法能够执行默认行为，无论Proxy怎么修改默认行为，总是可以通过Reflect对应的方法获取默认行为。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj name，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>链接：<a href="https://www.jianshu.com/p/f0f8ae715f9b">https://www.jianshu.com/p/f0f8ae715f9b</a></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>JS stringApi</title>
    <url>/2021/10/21/stringApi/</url>
    <content><![CDATA[<hr>
<h1 id="javascript-字符串API"><a href="#javascript-字符串API" class="headerlink" title="javascript 字符串API"></a>javascript 字符串API</h1><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h3><p>返回指定位置的字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>))<span class="comment">//a</span></span><br></pre></td></tr></table></figure>

<h3 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h3><p>返回在指定的位置的字符的 Unicode 编码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc&quot;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charCodeAt</span>(<span class="number">1</span>))<span class="comment">//98</span></span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>连接字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">concat</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//abcdef</span></span><br></pre></td></tr></table></figure>

<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>检索字符串，对大小写敏感，返回字符串起始字符的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;Hello world!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;Hello&quot;</span>))<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;World&quot;</span>))<span class="comment">//-1,表示当前字符串没有检索的字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;world&quot;</span>))<span class="comment">///6</span></span><br></pre></td></tr></table></figure>

<h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;1 abc 2 def 3&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>))<span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc Def!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(<span class="regexp">/abc/</span>, <span class="string">&quot;CBA&quot;</span>))<span class="comment">//CBA Def!</span></span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。要执行忽略大小写的检索，请追加标志 i。如果没有找到任何匹配的子串，则返回 -1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc DEF!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">search</span>(<span class="regexp">/DEF/</span>))<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>提取字符串的片断，并在新的字符串中返回被提取的部分。<br>stringObject.slice(start,end);<br>start :要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。<br>end：紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc def ghk&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">6</span>))<span class="comment">//f ghk</span></span><br></pre></td></tr></table></figure>

<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>将字符串分割为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc def ghi jkl&quot;</span>    </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>))<span class="comment">//[&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) )<span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot; &quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot; &quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot; &quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>,<span class="number">3</span>))<span class="comment">//[&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="toLocaleLowerCase"><a href="#toLocaleLowerCase" class="headerlink" title="toLocaleLowerCase()"></a>toLocaleLowerCase()</h3><p>把字符串转换为小写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;ABC def!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toLocaleLowerCase</span>())<span class="comment">//abc def!</span></span><br></pre></td></tr></table></figure>

<h3 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase()"></a>toLocaleUpperCase()</h3><p>把字符串转换为大写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;ABC def!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toLocaleUpperCase</span>())<span class="comment">//ABC DEF!</span></span><br></pre></td></tr></table></figure>

<h3 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h3><p>从起始索引号提取字符串中指定数目的字符。<br>stringObject.substr(start,length)。<br>start： 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。<br>length： 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc def&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">2</span>))<span class="comment">//c def</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">2</span>,<span class="number">4</span>))<span class="comment">// c de </span></span><br></pre></td></tr></table></figure>

<h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><p>提取字符串中两个指定的索引号之间的字符。<br>stringObject.substring(start,stop)。<br>start ： 必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。<br>stop ： 可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abc def&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">2</span>))<span class="comment">//c def</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">2</span>,<span class="number">4</span>))<span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<p>相同点： 如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。<br>substr(startIndex);<br>substring(startIndex);</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123456789&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">2</span>));    <span class="comment">//  &quot;3456789&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">2</span>)) ;<span class="comment">//  &quot;3456789&quot;</span></span><br></pre></td></tr></table></figure>
<p>不同点： 第二个参数<br>substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）；<br>substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123456789&quot;</span>.<span class="title function_">substr</span>(<span class="number">2</span>,<span class="number">5</span>));    <span class="comment">//  &quot;34567&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123456789&quot;</span>.<span class="title function_">substring</span>(<span class="number">2</span>,<span class="number">5</span>)) ;<span class="comment">//  &quot;345&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6新增的操作字符串的方法"><a href="#ES6新增的操作字符串的方法" class="headerlink" title="ES6新增的操作字符串的方法"></a>ES6新增的操作字符串的方法</h2><h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line">s.<span class="title function_">codePointAt</span>(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.<span class="title function_">codePointAt</span>(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line">s.<span class="title function_">codePointAt</span>(<span class="number">2</span>) <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<p>codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。</p>
<h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><p>ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;ஷ&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。<br>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的遍历器接口-for-of"><a href="#字符串的遍历器接口-for-of" class="headerlink" title="字符串的遍历器接口 for of"></a>字符串的遍历器接口 for of</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><p>at方法可以识别Unicode 编号大于0xFFFF的字符，返回正确的字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">‘abc’.<span class="title function_">at</span>(<span class="number">0</span>)<span class="comment">//&quot;a&quot;</span></span><br><span class="line"><span class="string">&#x27;吉&#x27;</span>.<span class="title function_">at</span>(<span class="number">0</span>)<span class="comment">//&quot;吉&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（u004F）和ˇ（u030C）合成Ǒ（u004Fu030C）。<br>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>===<span class="string">&#x27;\u004F\u030C&#x27;</span> <span class="comment">//false    </span></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。<br>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.<span class="title function_">normalize</span>() === <span class="string">&#x27;\u004F\u030C&#x27;</span>.<span class="title function_">normalize</span>()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">**<span class="title function_">includes</span>()**：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line">**<span class="title function_">startsWith</span>()**：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line">**<span class="title function_">endsWith</span>()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;    </span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;    </span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数如果是小数，会被取整。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2.9</span>) <span class="comment">// &quot;nana&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果repeat的参数是负数或者Infinity，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。<br>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;xxx&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br><span class="line"><span class="string">&#x27;xxx&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0123456789&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>) <span class="comment">// &#x27;   x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>) <span class="comment">// &#x27;x   &#x27;</span></span><br></pre></td></tr></table></figure>
<p>padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一个用途是提示字符串格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h3><p>matchAll方法返回一个正则表达式在当前字符串的所有匹配</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>在腾讯云搭建个人博客</title>
    <url>/2022/01/10/tencentyun/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>购买腾讯云的轻量级应用服务器</li>
<li>选择操作系统宝塔linux面板-q7x6</li>
<li>选择node.js镜像默认安装有nginx</li>
<li>重置密码</li>
<li>mac使用zssh，windows安装Putty远程ssh连接服务器输入刚才设置的账号密码，windows连接端口选为22，mac命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh root@xx.xxx..xx.x//root为默认用户名根据实际情况修改</span><br></pre></td></tr></table></figure></li>
<li>安装git<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install git</span><br></pre></td></tr></table></figure></li>
<li>找到nginx的配置文件并且修改<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locate nginx.conf</span><br></pre></td></tr></table></figure></li>
<li>找到nginx的html路径<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/lighthouse/softwares/nginx//腾讯云node.js镜像默认在此路径</span><br></pre></td></tr></table></figure></li>
<li>clone托管在github仓库中的博客</li>
<li>重启nginx<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/lighthouse/softwares/nginx/sbin</span><br><span class="line">$ ./nginx -s reload</span><br></pre></td></tr></table></figure>
之后访问端口即可看到博客</li>
<li>腾讯云申请域名，将域名解析到自己的轻量级应用服务器，之后再根据提示完成域名备案即可</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>比较vue和react</title>
    <url>/2021/08/09/vuevsreact/</url>
    <content><![CDATA[<h2 id="VUE和react比较"><a href="#VUE和react比较" class="headerlink" title="VUE和react比较"></a>VUE和react比较</h2><h4 id="单页面应用的发展"><a href="#单页面应用的发展" class="headerlink" title="单页面应用的发展"></a>单页面应用的发展</h4><ul>
<li>经典的多页面==&gt; 交互方式<ul>
<li>前后端融合在一起，开发和维护效率方式差</li>
<li>用户体验一般，点击刷新跳转，等待时间长</li>
<li>每个页面都需要重新加载</li>
</ul>
</li>
<li>现代式的单页面==&gt; 所有的交互都是在一个页面，不存在刷新<ul>
<li>开发方式好，采用前后端分离的开发模式</li>
<li>服务端不关心界面，只关心数据</li>
<li>客户端不关心数据库和数据操作，只关心通过接口拿到的数据和服务端交互，处理界面</li>
<li>用户体验好，就像是原生客户端软件一样，点击刷新跳转，等待时间不长</li>
<li>只需要加载局部视图即可，不需要整页刷新</li>
<li>单界面应用开发技术复杂，所以出现了很多框架AngularJS，ReactJS，VueJS，单页面应用被广泛的应用在webapp和管理系统上。</li>
</ul>
</li>
</ul>
<h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><p> <a href="https://cn.vuejs.org/">vue</a>是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><p><a href="https://react.docschina.org/">React</a>是一个帮助构建页面UI的库，相较于MVC框架，只能算是其中的View层。能够帮助我们把页面分割成各个单独独立的小模块，每个小模块就是一个组件，这些组件相互组合、嵌套，就构成了复杂庞大的页面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloMessage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Hello &#123;this.props.name&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&quot;Taylor&quot;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hello-example&#x27;</span>)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>从简介上来看，vue和react并没有什么区别，实际上两者的目标也都是能够更加高效的进行web开发，在这方面他们有很多的共同点</p>
<ol>
<li>Virtual DOM<br>传统的web开发都是直接通过DOM操作来进行页面的交互改动，而直接上DOM操作。实际上DOM操作对性能的浪费很大，操作DOM节点远比操作对象的消耗更大，因此在react中首先引入了Virtual DOM的概念，实际上就是虚拟DOM使用javascrpt对象模拟DOM元素，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。 而vue也延续了react虚拟DOM的思想例子如下，我们可以看看下面这个列表在HTML中的代码是如何写的：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;ul&#x27;</span>, </span><br><span class="line">    <span class="attr">props</span>: &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;list&#x27;</span>&#125;, </span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">props</span>: &#123;&#125;, <span class="attr">children</span>: [<span class="string">&#x27;item 1&#x27;</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">props</span>: &#123;&#125;, <span class="attr">children</span>: [<span class="string">&#x27;item 2&#x27;</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而能够实现这一思想的核心是<a href="https://www.cnblogs.com/wind-lanyan/p/9061684.html">diff算法</a>。调用名为 patch 的函数，比较新旧节点。一边比较一边给真实的 DOM 打补丁。patch 函数接收两个参数 oldVnode 和 Vnode，它们分别代表新的节点和之前的旧节点。这个patch函数会比较 oldVnode 和 vnode 是否是相同的, 即函数 sameVnode(oldVnode, vnode), 根据这个函数的返回结果分如下两种情况：true：则执行 patchVnode， false：则用 vnode 替换 oldVnode。</p>
<ol start="2">
<li>组件化<br>React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。你可以认为组件就是用户界面中的一小块。例如在一个gm系统中，导航栏是一个组件，tab选项是一个组件，table表格是一个组件。<br>vue中的组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;<span class="comment">//模板</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>//组件的根容器</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="comment">//state数据部分</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//子组件注册部分</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  methods：&#123;&#125;<span class="comment">//组件中的方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">//css样式</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>react中的组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;<span class="comment">//引入react包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PastaItem</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;<span class="comment">//注册组件</span></span><br><span class="line"><span class="comment">//定义方法和state</span></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;<span class="comment">//渲染函数</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">//jsx语法糖</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;pasta-dish list-unstyled&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PastaItem</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构建工具<br>React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。 由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。而vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。 事实上说，两个工具都非常好用，都能建立一个好环境。</li>
<li>配套框架<br>Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。 而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4></li>
<li>模板 vs <a href="https://www.jianshu.com/p/3345e94baec0">JSX</a><br>React与Vue最大的不同是模板的编写。Vue鼓励你去写近似常规HTML的模板。写起来很接近标准HTML元素，只是多了一些属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p> Vue鼓励你去使用HTML模板去进行渲染，通过把原有的模板整合成新的Vue模板，Vue很容易提供旧的应用的升级。这也让新来者很容易适应它的语法。 另一方面，React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。同样的代码，用JSX书写的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul className=<span class="string">&quot;pasta-list&quot;</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">pastadishes</span>).<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">PastaItem</span> <span class="attr">index</span>=<span class="string">&#123;key&#125;</span> <span class="attr">key</span>=<span class="string">&#123;key&#125;</span> <span class="attr">details</span>=<span class="string">&#123;this.state.pastadishes[key]&#125;</span> <span class="attr">addToOrder</span>=<span class="string">&#123;this.addToOrder&#125;</span> <span class="attr">orders</span>=<span class="string">&#123;this.state.orders[key]&#125;</span> /&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>状态管理 vs 对象属性<br>应用中的状态是React关键的概念。也有一些配套框架被设计为管理一个大的state对象，如Redux。此外，state对象在React应用中是不可变的，意味着它不能被直接改变。在React中你需要使用setState()方法去更新状态。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addToOrder</span>(<span class="params">key</span>) &#123;</span><br><span class="line">       <span class="comment">//Make a copy of this.state</span></span><br><span class="line">       <span class="keyword">const</span> orders = &#123; ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">orders</span> &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//update or add</span></span><br><span class="line">       orders[ key ] = orders[ key ] + <span class="number">1</span> || <span class="number">1</span>;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>( &#123; orders &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">samplePasta</span>: samplePasta,</span><br><span class="line">      <span class="attr">orders</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">handleOrder</span>: <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">orders</span>.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">orders</span>, key, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">orders</span>[key].<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>类组件vs声明式组件</li>
</ol>
<p>vue是声明式的写法，通过传入各种options，api和参数都很多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而react则是通过es6的class构建组件，基本没有框架自定义的api，你只要了解class，就能完成组件的编写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;<span class="comment">//引入react包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PastaItem</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;<span class="comment">//注册组件</span></span><br><span class="line"><span class="comment">//定义方法和state</span></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;<span class="comment">//渲染函数</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">//jsx语法糖</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;pasta-dish list-unstyled&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PastaItem</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>模板vs all in js<br>Vue组件实现为一个有模板（template）、有数据（props）的对象， React组件则实现为一个输入数据（props）、输出html片段（JSX）的函数。这是两者之间核心思想的区别，是html为主导还是js为主导，vue的模板思想倾向于传统的web开发，以html为主导，先搭建完整的页面，再由js作为辅助工具，完成页面的逻辑和交互。而在react的all in js思想中，则认为js为主导，react提倡函数式编程，将html视为数据映射的结果。一个数据映射出一个html片段，所有的html片段拼起来，就形成了完整的页面DOM树。当然，React组件一般是class形式，但只是为了更好地操作数据，最终render函数会完成映射这一步。从这一点看vue的设计理念是为了让开发者更舒服，没有改变原有的开发思想，只是提供了让开发更加高效和简洁的工具，而react则是想颠覆js服务html的开发逻辑，让js成为主导，从而使前端开发逻辑更加严谨，更加灵活。</li>
</ol>
<h2 id="浅谈vue和react的发展"><a href="#浅谈vue和react的发展" class="headerlink" title="浅谈vue和react的发展"></a>浅谈vue和react的发展</h2><p> 实际上vue和react虽然核心思想的侧重点不同，但是二者的目标都是使前端开发脱离频繁的dom操作，工程化，模块化。前端开发在组件化时代最大的问题就是如何优雅的实现组件的复用，当一个组件业务较多，数据量大的时候，虽然两个组件可能存在一定的相似性，但很难实现复用。在组件复用的道路上两者都经历了Mixin -&gt; Hoc（Vue 比较少用）-&gt; render prop（Vue 有类似思想的实现为 slot） -&gt; hooks（Vue3.0 function based API。而在数据流上两者也向着同一个方向发展，最开始的vue数据流是双向的，后来除了双向绑定的数据也接受了react的单向数据流思想，单向数据流的概念就好比是人和影子，人的改变可以带动影子的改变，但是影子不能主动改变带动人的变化，这对数据的一致性来讲是很关键的。vue和react在发展优化的过程中，逐渐的统一了某些思想。我认为在之后的持续发展中，二者会更加相似，会互相学习最终会出现一个相对完美的框架，引领前端革命。</p>
<h2 id="优劣势对比"><a href="#优劣势对比" class="headerlink" title="优劣势对比"></a>优劣势对比</h2><p>总的来说我认为在实际的开发中vue有以下几点优势</p>
<ul>
<li>渐进式，可以向上兼容和向下兼容</li>
<li>模板完善，大部分时候你只需要关心数据的变化，开发难度低，工作量小</li>
<li>更小的体积更快的速度，vue打包之后的文件很小，加之双向绑定更新数据的模式，使得加载更快性能更佳（实际上react的ui组件一般都是按需引入，打包体积会小一点，vue一般是全局引入，加上像router，vuex，redux，之类的库，最终的打包文件还是以项目需求为准）</li>
</ul>
<p>同样vue也有一些劣势</p>
<ul>
<li>因为模板的局限性，过于复杂的业务场景实现起来就显得有点笨重，不够灵活。</li>
<li>双向绑定的局限性，当数据量过大的时候过多的watch双向绑定会导致页面卡顿。我做过一个测试，在10W条表格数据切换时会有轻微卡顿，100w条时卡顿就十分明显了（此条在vue3.0的测试下没有问题，因为vue3.0更换了双向绑定的逻辑，从es5的object.defineproperty()变成了es6的proxy）</li>
</ul>
<p>相比之下react的优势是</p>
<ul>
<li>灵活的语法，没有模板和过多的api，从业务到渲染全部通过js完成，面对复杂业务就显得很从容。也会减轻debug和测试的难度</li>
<li>对于大量的数据，虽然操作起来繁琐，但是不会影响页面性能。</li>
<li>hook让组件的业务逻辑更清晰明了，便于组件的管理，脱离面相生命周期编程（vue3.0的setup有类似的实现···）</li>
</ul>
<p>劣势</p>
<ul>
<li>过于灵活的语法对开发者要求很高，很容易让整个项目显得杂乱。难以维护</li>
<li>react的api很少，大部分的功能业务事件都需要自己去完成，工作量大。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>我个人感觉写vue的话像是在完成任务，就像你需要一个能用的东西就行，vue就是一个完美的选择，优秀的模板，完善的文档api会让你开发效率很高。而react的话像是在创造，all in js 的理念颠覆了前端的概念，也可能是未来前端的趋势，vue的作者尤雨溪也提到如果多年以后要论历史地位，react 肯定是高于 ue 的。vue的定位一开始就是服务开发者，让开发者的工作更简单。而react的定位是提出 UI 开发的新思路，要改变前端开发的传统模式。所以我觉得就技术层面而言两者对于业务的实现性能等方面并没有太大的区别，只能说两者发展方向不同，vue想做优秀的工具，react则是想改变业界，前端革命。</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>webpack+threejs</title>
    <url>/2021/12/23/webpack/</url>
    <content><![CDATA[<h1 id="threejsStudy"><a href="#threejsStudy" class="headerlink" title="threejsStudy"></a>threejsStudy</h1><h2 id="使用-webpack-搭建-threejs-项目"><a href="#使用-webpack-搭建-threejs-项目" class="headerlink" title="使用 webpack 搭建 threejs 项目"></a>使用 webpack 搭建 threejs 项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add --save-dev webpack</span><br><span class="line">$ yarn add --save-dev webpack-cli</span><br><span class="line">$ yarn add --save-dev webpack-dev-server</span><br><span class="line">$ yarn add three -save</span><br><span class="line">$ yarn add cross-env -save</span><br><span class="line">$ yarn add copy-webpack-plugin -save</span><br></pre></td></tr></table></figure>

<h2 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack,config.js"></a>配置 webpack,config.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> copyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/index.js&quot;</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/dist&quot;</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">static</span>: &#123;</span><br><span class="line">      <span class="attr">directory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;./dist/src&quot;</span>),</span><br><span class="line">    &#125;, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&quot;8088&quot;</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, <span class="comment">//不跳转</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title function_">copyWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">//使用threejs加载字体json文件的时候使用url路径，打包无法识别，目前没想到更好的办法，打包成静态资源</span></span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">from</span>: __dirname + <span class="string">&quot;/src&quot;</span>,</span><br><span class="line">          <span class="attr">to</span>: <span class="string">&quot;./src&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="学习过程，陆续更新。"><a href="#学习过程，陆续更新。" class="headerlink" title="学习过程，陆续更新。"></a>学习过程，陆续更新。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FontLoader</span> &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/loaders/FontLoader.js&quot;</span>; <span class="comment">//FontLoader已经不在全局需要局部引入</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>webgl</title>
    <url>/2021/12/23/webgl/</url>
    <content><![CDATA[<h2 id="什么是webgl"><a href="#什么是webgl" class="headerlink" title="什么是webgl"></a>什么是webgl</h2><ul>
<li>webgl是一种3D绘图标准，把javascript和opengl结合在一起，铜鼓opengl es2.0的一个javascript绑定，通过使用html5的canvas进行绘制。</li>
<li>webgl的本质是基于光栅化的api，webgl只关注两个方面，矩阵的坐标和投影矩阵的颜色，使用webgl的程序的任务就是实现带有投影矩阵的坐标和颜色的webgl对象</li>
<li>3D绘图是由三部分组成，光照，摄像机，场景。webgl也是一样</li>
<li>webgl可以绘制的图形为点,线,三角形，所有复杂的几何图形都是由三角形组成</li>
<li>webgl绘图的流程，获取顶点坐标-&gt;绘制顶点数组对象-&gt;顶点着色器-&gt;片元着色器。</li>
</ul>
<h2 id="创建第一个webgl视图"><a href="#创建第一个webgl视图" class="headerlink" title="创建第一个webgl视图"></a>创建第一个webgl视图</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#glcanvas&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化WebGL上下文</span></span><br><span class="line">  <span class="keyword">const</span> gl = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确认WebGL支持性</span></span><br><span class="line">  <span class="keyword">if</span> (!gl) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;无法初始化WebGL，你的浏览器、操作系统或硬件等可能不支持WebGL。&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用完全不透明的黑色清除所有图像</span></span><br><span class="line">  gl.<span class="title function_">clearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  <span class="comment">// 用上面指定的颜色清除缓冲区</span></span><br><span class="line">  gl.<span class="title function_">clear</span>(gl.<span class="property">COLOR_BUFFER_BIT</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合MDN和three.js慢慢学习</p>
]]></content>
      <tags>
        <tag>webgl</tag>
      </tags>
  </entry>
</search>
